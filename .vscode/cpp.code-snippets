{
	// Place your c-_project 工作區 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"ishowspeed": {
		"prefix": [
			"ishowspeed"
		],
		"body": [
			"ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);"
		],
		"description": "default code"
	},
	"fastio": {
		"prefix": [
			"fastio"
		],
		"body": [
			"bool w = 0; char c ;",
			"template<typename T>",
			"inline void re(T &a) {",
			"c = getchar();a = 0; while(c < '0' || c > '9') w|=(c=='-') , c=getchar();",
			"while(c >= '0' && c <= '9') a = (a<<1) + (a<<3) + (c&15) , c = getchar();",
			"if(w) a=-a;",
			"return ;}",
			"char st[30] ; int kkkk = 0;",
			"template<typename T>",
			"inline void wr(T a) {",
			"if(a==0) { putchar('0') ; return ;}",
			"if(a<0)putchar('-') , a=-a;",
			"while(a) { st[kkkk++] = a % 10 + '0' , a/=10;}",
			"while(kkkk) { putchar(st[--kkkk]);}",
			"return ;}"
		],
		"description": "default code"
	},
	"pragma": {
		"prefix": [
			"pragma"
		],
		"body": [
			"#pragma GCC optimize(3)",
			"#pragma GCC optimize(\"Ofast\")",
			"#pragma GCC optimize(\"inline\")",
			"#pragma GCC optimize(\"-bmi -bmi2 -popcnt -abm -lzcnt -tbm -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -mavx -mavx2 -mfma -mbmi -mbmi2 -mpopcnt -mabm -mlzcnt -mtbm -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -mavx -mavx2 -mfma -mbmi -mbmi2 -mpopcnt -mabm -mlzcnt -mtbm\")",
			"#pragma G++ optimize(3)",
			"#pragma G++ optimize(\"Ofast\")",
			"#pragma G++ optimize(\"inline\")",
			"#pragma G++ optimize(\"-bmi -bmi2 -popcnt -abm -lzcnt -tbm -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -mavx -mavx2 -mfma -mbmi -mbmi2 -mpopcnt -mabm -mlzcnt -mtbm -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2 -mavx -mavx2 -mfma -mbmi -mbmi2 -mpopcnt -mabm -mlzcnt -mtbm\")",
		]
	},
	"Dinic": {
		"prefix": "Dinic",
		"body": [
			"#define SZ(X) (int)(X).size()",
			"#define PB push_back",
			"constexpr int MXN = 1e5+4;",
			"struct Dinic",
			"{",
			"    struct Edge",
			"    {",
			"        int v, f, re;",
			"    };",
			"    int n, s, t, level[MXN];",
			"    vector<Edge> E[MXN];",
			"    void init(int _n, int _s, int _t)",
			"    {",
			"        n = _n;",
			"        s = _s;",
			"        t = _t;",
			"        for (int i = 0; i < n; i++)",
			"            E[i].clear();",
			"    }",
			"    void add_edge(int u, int v, int f)",
			"    {",
			"        E[u].PB({v, f, SZ(E[v])});",
			"        E[v].PB({u, 0, SZ(E[u]) - 1});",
			"    }",
			"    bool BFS()",
			"    {",
			"        for (int i = 0; i < n; i++)",
			"            level[i] = -1;",
			"        queue<int> que;",
			"        que.push(s);",
			"        level[s] = 0;",
			"        while (!que.empty())",
			"        {",
			"            int u = que.front();",
			"            que.pop();",
			"            for (auto it : E[u])",
			"            {",
			"                if (it.f > 0 && level[it.v] == -1)",
			"                {",
			"                    level[it.v] = level[u] + 1;",
			"                    que.push(it.v);",
			"                }",
			"            }",
			"        }",
			"        return level[t] != -1;",
			"    }",
			"    int DFS(int u, int nf)",
			"    {",
			"        if (u == t)",
			"            return nf;",
			"        int res = 0;",
			"        for (auto &it : E[u])",
			"        {",
			"            if (it.f > 0 && level[it.v] == level[u] + 1)",
			"            {",
			"                int tf = DFS(it.v, min(nf, it.f));",
			"                res += tf;",
			"                nf -= tf;",
			"                it.f -= tf;",
			"                E[it.v][it.re].f += tf;",
			"                if (nf == 0)",
			"                    return res;",
			"            }",
			"        }",
			"        if (!res)",
			"            level[u] = -1;",
			"        return res;",
			"    }",
			"    int flow(int res = 0)",
			"    {",
			"        while (BFS())",
			"            res += DFS(s, 2147483647);",
			"        return res;",
			"    }",
			"} flow;",
		]
	},
	"km": {
		"prefix": "km",
		"body": [
			"vector<pair<int,int>> rot",
			"struct KM { // max weight, for min negate the weights",
			"int n, mx[MXN",
			"], my[MXN",
			"], pa[MXN",
			"];",
			"ll g[MXN",
			"][MXN",
			"], lx[MXN",
			"], ly[MXN",
			"], sy[MXN",
			"];",
			"bool vx[MXN",
			"], vy[MXN",
			"];",
			"void init(int _n) { // 1-based, N個節點",
			"n = _n;",
			"for (int i = 1; i <= n; i++)",
			"fill(g[i",
			"], g[i",
			"] + n + 1,",
			"0);",
			"}",
			"void addEdge(int x, int y, ll w) {",
			"g[x",
			"][y",
			"] = w;",
			"} //左邊的集合節點x連邊右邊集合節點y權重為w",
			"void augment(int y) {",
			"for (int x, z; y; y = z)",
			"x = pa[y",
			"], z = mx[x",
			"], my[y",
			"] = x, mx[x",
			"] = y;",
			"}",
			"void bfs(int st) {",
			"for (int i = 1; i <= n; ++i)",
			"sy[i",
			"] = INF, vx[i",
			"] = vy[i",
			"] = 0;",
			"queue<int> q;",
			"q.push(st);",
			"for (;;) {",
			"while (q.size()) {",
			"int x = q.front();",
			"q.pop();",
			"vx[x",
			"] = 1;",
			"for (int y = 1; y <= n; ++y)",
			"if (!vy[y",
			"]) {",
			"ll t = lx[x",
			"] + ly[y",
			"] - g[x",
			"][y",
			"];",
			"if (t == 0) {",
			"pa[y",
			"] = x;",
			"if (!my[y",
			"]) {",
			"augment(y);",
			"return;",
			"}",
			"vy[y",
			"] = 1, q.push(my[y",
			"]);",
			"} else if (sy[y",
			"] > t)",
			"pa[y",
			"] = x, sy[y",
			"] = t;",
			"}",
			"}",
			"ll cut = INF;",
			"for (int y = 1; y <= n; ++y)",
			"if (!vy[y",
			"] && cut > sy[y",
			"])",
			"cut = sy[y",
			"];",
			"for (int j = 1; j <= n; ++j) {",
			"if (vx[j",
			"])",
			"lx[j",
			"] -= cut;",
			"if (vy[j",
			"])",
			"ly[j",
			"] += cut;",
			"else",
			"sy[j",
			"] -= cut;",
			"}",
			"for (int y = 1; y <= n; ++y)",
			"if (!vy[y",
			"] && sy[y",
			"] == 0) {",
			"if (!my[y",
			"]) {",
			"augment(y);",
			"return;",
			"}",
			"vy[y",
			"] = 1, q.push(my[y",
			"]);",
			"}",
			"}",
			"}",
			"ll solve() { // 回傳值為完美匹配下的最大總權重",
			"fill(mx, mx + n + 1,",
			"0);",
			"fill(my, my + n + 1,",
			"0);",
			"fill(ly, ly + n + 1,",
			"0);",
			"fill(lx, lx + n + 1, -INF);",
			"for (int x = 1; x <= n; ++x)",
			"for (int y = 1; y <= n; ++y) // 1-base",
			"lx[x",
			"] = max(lx[x",
			"], g[x",
			"][y",
			"]);",
			"for (int x = 1; x <= n; ++x)",
			"bfs(x);",
			"ll ans = 0;",
			"for (int y = 1; y <= n; ++y) {",
			"ans += g[my[y",
			"]",
			"][y",
			"];",
			"rot.push_back(make_pair(my[y",
			"], y));",
			"}",
			"return ans;",
			"}",
			"} graph;",
		]
	}
}